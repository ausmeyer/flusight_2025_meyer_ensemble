---
title: "Retrospective WIS Evaluation (Pipeline Outputs)"
subtitle: "Per-horizon and combined WIS and relative WIS since 2025-07-01"
author: "Pipeline Evaluation"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: flatly
    toc: false
    code_folding: hide
    fig_width: 14
    fig_height: 8
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 14,
  fig.height = 8
)

library(dplyr)
library(readr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(knitr)
```

Generated on: `r Sys.time()`

# Retrospective WIS Evaluation (Pipeline Outputs)

```{r pipeline-wis}
EVAL_START <- as.Date('2025-07-01')

# Helper: latest file in a directory by pattern
latest_file <- function(dir, pattern) {
  files <- list.files(dir, pattern = pattern, full.names = TRUE)
  if (length(files) == 0) return(NA_character_)
  files[order(files)][length(files)]
}

# Load latest actuals
actual_path <- latest_file('../data/imputed_sets', '^imputed_and_stitched_hosp_\\d{4}-\\d{2}-\\d{2}\\.csv$')
stopifnot(!is.na(actual_path))
actual_raw <- read_csv(actual_path, show_col_types = FALSE)

# Map location_name -> FIPS
location_to_fips <- c(
  'Alabama'='01','Alaska'='02','Arizona'='04','Arkansas'='05','California'='06','Colorado'='08','Connecticut'='09','Delaware'='10',
  'District of Columbia'='11','Florida'='12','Georgia'='13','Hawaii'='15','Idaho'='16','Illinois'='17','Indiana'='18','Iowa'='19',
  'Kansas'='20','Kentucky'='21','Louisiana'='22','Maine'='23','Maryland'='24','Massachusetts'='25','Michigan'='26','Minnesota'='27',
  'Mississippi'='28','Missouri'='29','Montana'='30','Nebraska'='31','Nevada'='32','New Hampshire'='33','New Jersey'='34','New Mexico'='35',
  'New York'='36','North Carolina'='37','North Dakota'='38','Ohio'='39','Oklahoma'='40','Oregon'='41','Pennsylvania'='42','Puerto Rico'='72',
  'Rhode Island'='44','South Carolina'='45','South Dakota'='46','Tennessee'='47','Texas'='48','Utah'='49','Vermont'='50','Virginia'='51',
  'Washington'='53','West Virginia'='54','Wisconsin'='55','Wyoming'='56','US'='US'
)

actual_data_full <- actual_raw %>%
  transmute(location = location_to_fips[location_name], date = as.Date(date), actual_value = total_hosp) %>%
  filter(!is.na(location))

# For evaluation summaries only (not used for weighting), restrict to EVAL_START+
actual_data <- actual_data_full %>% filter(date >= EVAL_START)

# Load model retrospective files for h=1..4
load_model <- function(path, model_name, h){
  if (!file.exists(path)) return(NULL)
  df <- read_csv(path, show_col_types = FALSE)
  df$model <- model_name
  df$h <- h
  df <- df %>% mutate(reference_date = as.Date(reference_date), target_end_date = as.Date(target_end_date))
  df
}

all_models <- list()
for (h in 1:4) {
  baseline_path_top <- sprintf('../forecasts/retrospective/Flusight-baseline_h%d_forecasts.csv', h)
  baseline_path_alt <- sprintf('../forecasts/retrospective/lgbm_enhanced_t10/Flusight-baseline_h%d_forecasts.csv', h)
  baseline_path <- if (file.exists(baseline_path_top)) baseline_path_top else baseline_path_alt
  baseline <- load_model(baseline_path, 'FluSight-baseline', h)
  arima <- load_model(sprintf('../forecasts/retrospective/arima/ARIMA_h%d_forecasts.csv', h), 'ARIMA', h)
  lgbm  <- load_model(sprintf('../forecasts/retrospective/lgbm_enhanced_t10/TwoStage-FrozenMu_h%d_forecasts.csv', h), 'LGBM', h)
  svm   <- load_model(sprintf('../forecasts/retrospective/svm_t100/svm_retrospective_h%d.csv', h), 'SVM', h)
  dfs <- list(baseline, arima, lgbm, svm)
  dfs <- dfs[!sapply(dfs, is.null)]
  if (length(dfs) > 0) all_models[[paste0('h', h)]] <- bind_rows(dfs)
}

stopifnot(length(all_models) > 0)
ret_all <- bind_rows(all_models)

# WIS function (log scale) used for weighting and evaluation
calculate_wis_single <- function(qvals, qlevels, actual_value){
  qlog <- log(as.numeric(qvals) + 1)
  alog <- log(as.numeric(actual_value) + 1)
  alphas <- unique(c(qlevels[qlevels <= 0.5], 1 - qlevels[qlevels > 0.5]))
  alphas <- alphas[alphas > 0]
  mean(sapply(alphas, function(a){
    li <- which.min(abs(qlevels - a)); ui <- which.min(abs(qlevels - (1 - a)))
    L <- qlog[li]; U <- qlog[ui]
    width <- U - L
    pen <- if (alog < L) (2/a) * (L - alog) else if (alog > U) (2/a) * (alog - U) else 0
    width + pen
  }))
}

# Build retrospective AdaptiveEnsemble from ARIMA/LGBM/SVM using prior 4 weeks per horizon
build_weights <- function(df_h, ref_date, lookback_weeks = 4) {
  # df_h: rows for a single horizon with columns: model, reference_date, target_end_date, location, output_type, output_type_id, value
  # Use only ARIMA/LGBM/SVM
  cand <- df_h %>% filter(model %in% c('ARIMA','LGBM','SVM'), output_type=='quantile')
  prev_refs <- sort(unique(cand$reference_date))
  prev_refs <- prev_refs[prev_refs < ref_date]
  if (length(prev_refs) == 0) return(setNames(rep(1/3, 3), c('ARIMA','LGBM','SVM')))
  eval_refs <- tail(prev_refs, lookback_weeks)
  # Compute WIS per model over eval_refs
  wis_by_model <- cand %>%
    filter(reference_date %in% eval_refs) %>%
    mutate(output_type_id = as.numeric(output_type_id)) %>%
    group_by(model, reference_date, target_end_date, location) %>%
    summarise(quantile_values = list(value), quantile_levels = list(output_type_id), .groups='drop') %>%
    # Use full history so weights can be computed just before EVAL_START
    left_join(actual_data_full, by=c('target_end_date'='date','location'='location')) %>%
    filter(!is.na(actual_value)) %>%
    rowwise() %>%
    mutate(wis = calculate_wis_single(unlist(quantile_values), unlist(quantile_levels), actual_value)) %>%
    ungroup() %>%
    group_by(model) %>%
    summarise(mean_wis = mean(wis, na.rm=TRUE), .groups='drop')
  models <- intersect(c('ARIMA','LGBM','SVM'), wis_by_model$model)
  if (length(models) == 0 || any(!is.finite(wis_by_model$mean_wis))) {
    return(setNames(rep(1/3, 3), c('ARIMA','LGBM','SVM')))
  }
  inv <- 1 / wis_by_model$mean_wis
  w <- inv / sum(inv)
  out <- setNames(rep(0, 3), c('ARIMA','LGBM','SVM'))
  out[wis_by_model$model] <- w
  out
}

build_ensemble_for_h <- function(ret_h) {
  # ret_h: rows for a single horizon across all models (including baseline)
  # We will produce model == 'AdaptiveEnsemble' rows using ARIMA/LGBM/SVM only
  cand <- ret_h %>% filter(model %in% c('ARIMA','LGBM','SVM'), output_type=='quantile')
  if (nrow(cand) == 0) return(NULL)
  ref_dates <- sort(unique(cand$reference_date))
  ens_list <- list()
  for (rd in ref_dates) {
    w <- build_weights(ret_h, rd, lookback_weeks = 4)
    # Combine forecasts at this ref date across models using weights
    comb <- cand %>%
      filter(reference_date == rd) %>%
      mutate(w = case_when(model=='ARIMA' ~ w['ARIMA'], model=='LGBM' ~ w['LGBM'], model=='SVM' ~ w['SVM'], TRUE ~ 0)) %>%
      group_by(reference_date, target_end_date, location, output_type_id) %>%
      summarise(value = ifelse(sum(w, na.rm=TRUE) > 0, sum(value * w, na.rm=TRUE) / sum(w, na.rm=TRUE), mean(value, na.rm=TRUE)), .groups='drop') %>%
      mutate(output_type = 'quantile', model = 'AdaptiveEnsemble')
    ens_list[[as.character(rd)]] <- comb
  }
  bind_rows(ens_list)
}

ens_all <- list()
for (h in sort(unique(ret_all$h))) {
  ret_h <- ret_all %>% filter(h == !!h)
  ens_h <- build_ensemble_for_h(ret_h)
  if (!is.null(ens_h) && nrow(ens_h) > 0) {
    ens_h$h <- h
    ens_all[[paste0('h', h)]] <- ens_h
  }
}

ens_all_df <- if (length(ens_all) > 0) bind_rows(ens_all) else NULL

retros <- if (!is.null(ens_all_df)) bind_rows(ret_all, ens_all_df) else ret_all
retros <- retros %>% filter(as.Date(target_end_date) >= EVAL_START)

# Compute WIS per horizon
wis_scores_all <- list()
for (h in sort(unique(retros$h))) {
  dfh <- retros %>% filter(h == !!h, output_type == 'quantile') %>% mutate(output_type_id = as.numeric(output_type_id))
  if (nrow(dfh) == 0) next
  wis_scores <- dfh %>%
    group_by(h, model, reference_date, target_end_date, location) %>%
    summarise(quantile_values = list(value), quantile_levels = list(output_type_id), .groups = 'drop') %>%
    left_join(actual_data, by = c('target_end_date' = 'date', 'location' = 'location')) %>%
    filter(!is.na(actual_value)) %>%
    rowwise() %>%
    mutate(interval_score = calculate_wis_single(unlist(quantile_values), unlist(quantile_levels), actual_value)) %>%
    ungroup()
  wis_scores_all[[paste0('h', h)]] <- wis_scores
}

wis_scores_all_df <- bind_rows(wis_scores_all) %>% filter(!(location %in% c('72','US')))

# Ensure identical date/location sets across models within each horizon
wis_common_list <- list()
for (hh in sort(unique(wis_scores_all_df$h))) {
  sub <- wis_scores_all_df %>% filter(h == !!hh)
  models_present <- unique(sub$model)
  keys <- sub %>%
    group_by(location, target_end_date) %>%
    summarise(n_models = n_distinct(model), .groups='drop') %>%
    filter(n_models == length(models_present)) %>%
    select(location, target_end_date)
  sub_common <- sub %>% inner_join(keys, by=c('location','target_end_date'))
  wis_common_list[[paste0('h', hh)]] <- sub_common
}

wis_scores_common <- bind_rows(wis_common_list)

# Per-horizon geometric mean WIS and relative WIS
wis_by_model <- wis_scores_common %>%
  group_by(h, model, location) %>%
  summarise(mean_wis_loc = mean(interval_score, na.rm=TRUE), .groups='drop') %>%
  group_by(h, model) %>%
  summarise(geometric_mean_wis = exp(mean(log(mean_wis_loc), na.rm=TRUE)), .groups='drop')

per_horizon_summary <- wis_by_model %>%
  group_by(h) %>%
  mutate(baseline_gmw = dplyr::first(geometric_mean_wis[model == 'FluSight-baseline'])) %>%
  mutate(relative_wis = ifelse(!is.na(baseline_gmw) & baseline_gmw > 0,
                               geometric_mean_wis / baseline_gmw,
                               NA_real_)) %>%
  select(-baseline_gmw) %>%
  ungroup()

cat("\nPER-HORIZON GEOMETRIC MEAN WIS AND RELATIVE WIS (>= 2025-07-01):\n\n")
print(knitr::kable(per_horizon_summary, digits = 4))

# Combined across horizons
combined_by_model <- wis_scores_common %>%
  group_by(model, location) %>%
  summarise(mean_wis_loc = mean(interval_score, na.rm=TRUE), .groups='drop') %>%
  group_by(model) %>%
  summarise(geometric_mean_wis = exp(mean(log(mean_wis_loc), na.rm=TRUE)), .groups='drop')

combined_summary <- combined_by_model %>%
  mutate(baseline_gmw = dplyr::first(geometric_mean_wis[model == 'FluSight-baseline'])) %>%
  mutate(relative_wis = ifelse(!is.na(baseline_gmw) & baseline_gmw > 0,
                               geometric_mean_wis / baseline_gmw,
                               NA_real_)) %>%
  select(-baseline_gmw)

cat("\nCOMBINED GEOMETRIC MEAN WIS AND RELATIVE WIS (All horizons, >= 2025-07-01):\n\n")
print(knitr::kable(combined_summary, digits = 4))
```
